<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chart Studio — Waves + Move Mode + Premium Zoom</title>
  <meta name="color-scheme" content="dark">
  <style>
    :root{
      --bg:#020305;
      --muted:#9aa7be;
      --accent:#6ee7b7;
      --accent2:#7c3aed;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#dbeafe;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;overflow:hidden}
    /* Layout */
    .app { height:100vh; display:grid; grid-template-columns:420px 1fr; gap:18px; padding:22px; box-sizing:border-box; align-items:stretch; position:relative; z-index:2; }
    @media(max-width:980px){ .app{ grid-template-columns: 1fr; padding:12px } .left{order:2} .right{order:1} }

    /* Waves background container (full screen, behind everything) */
    #bgContainer { position:fixed; inset:0; z-index:0; pointer-events:none; filter:contrast(1.05) saturate(1.05); }

    /* Panels are transparent so waves show through (except chart card) */
    .left, .right, .studioTop {
      background: transparent;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .left { position:relative; z-index:2; padding:18px; min-height:70vh; display:flex; flex-direction:column; gap:12px; }
    .right{ position:relative; z-index:2; display:flex; flex-direction:column; gap:12px; min-height:70vh; }
    .studioTop{ height:160px; border-radius:12px; overflow:hidden; position:relative; }

    /* Chart card remains dark/opaque for legibility */
    .chartCard{ padding:12px; min-height:360px; box-shadow:0 10px 30px rgba(2,6,23,0.48); overflow:hidden; background: linear-gradient(180deg, rgba(0,0,0,0.78), rgba(0,0,0,0.62)); border-radius:12px; border:1px solid rgba(255,255,255,0.04); z-index:3 }

    .termTitle{font-family:var(--mono); font-weight:600; letter-spacing:0.4px; color:#cfe8ff}
    .controls { display:flex; flex-direction:column; gap:8px; margin-top:6px; font-size:13px }
    label.block{display:block;color:var(--muted);font-size:12px;margin-bottom:6px}
    textarea,input,select{width:100%; box-sizing:border-box; background:transparent;border:1px solid rgba(255,255,255,0.04); color:inherit; padding:10px; border-radius:8px; font-family:var(--mono); font-size:13px}
    textarea{min-height:110px; resize:vertical}
    .row{display:flex;gap:8px}
    .row .small{flex:1}
    .row .mini{width:86px}
    .btn{padding:9px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:linear-gradient(90deg,var(--accent),var(--accent2));color:#04111a;font-weight:600;cursor:pointer}
    .ghost{background:transparent;border:1px solid rgba(255,255,255,0.04); color:var(--muted)}
    .muted{color:var(--muted);font-size:12px}
    .chip{ padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.02); font-family:var(--mono); font-size:13px }

    /* Chart canvas black-glass */
    canvas#chartCanvas{ width:100% !important; height:460px !important; display:block; background: linear-gradient(180deg, rgba(0,0,0,0.78), rgba(0,0,0,0.62)); border-radius:8px; cursor:grab; }

    canvas#chartCanvas.dragging { cursor:grabbing; }

    /* Premium zoom slider style */
    .zoomWrap { display:flex; gap:12px; align-items:center; }
    .zoomLabel { color:#cfe8ff; font-family:var(--mono); font-size:13px; }
    .zoomSlider {
      -webkit-appearance:none; width:260px; height:12px; background: linear-gradient(90deg,var(--accent),var(--accent2)); border-radius:999px; padding:2px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
    }
    .zoomSlider::-webkit-slider-thumb {
      -webkit-appearance:none; width:22px; height:22px; border-radius:50%; background:#fff; box-shadow:0 6px 18px rgba(0,0,0,0.4);
      border:4px solid rgba(0,0,0,0.35);
      margin-top:-6px;
    }
    .zoomSlider::-moz-range-thumb { width:22px; height:22px; border-radius:50%; background:#fff; border:4px solid rgba(0,0,0,0.35); }

    .moveIndicator { font-family:var(--mono); color:#9fd8ff; font-size:13px; }

    /* Waves canvas */
    .waves-canvas { width:100%; height:100%; display:block; }

    @media(max-width:520px){ .left{ padding:12px } .termTitle{font-size:13px} canvas#chartCanvas{height:320px!important} .zoomSlider{width:160px} }
  </style>
</head>
<body>
  <!-- Waves background container -->
  <div id="bgContainer" aria-hidden></div>

  <div class="app">
    <!-- Left terminal panel (transparent) -->
    <div class="left">
      <div style="display:flex;gap:10px;align-items:center">
        <div style="display:flex;gap:6px"><div style="width:12px;height:12px;border-radius:50%;background:#ff5f57"></div><div style="width:12px;height:12px;border-radius:50%;background:#ffbd2e"></div><div style="width:12px;height:12px;border-radius:50%;background:#28c93f"></div></div>
        <div class="termTitle">chart-studio — terminal</div>
      </div>

      <div class="controls">
        <div>
          <label class="block">Project name</label>
          <input id="projectName" placeholder="Demo Project" value="Demo Project" />
        </div>

        <div>
          <label class="block">Paste X values (comma/space/newline/semicolon)</label>
          <textarea id="xvals">1,2,3,4,5,6,7,8</textarea>
        </div>

        <div>
          <label class="block">Paste Y values (same length as X)</label>
          <textarea id="yvals">10,18,15,21,30,28,34,40</textarea>
        </div>

        <div class="row">
          <select id="chartType" class="small">
            <option value="line">Line</option>
            <option value="scatter">Scatter</option>
            <option value="bar">Bar</option>
            <option value="area">Area</option>
          </select>
          <select id="interpolation" class="mini">
            <option value="0.0">No smoothing</option>
            <option value="0.2" selected>Low</option>
            <option value="0.4">Medium</option>
            <option value="0.7">High</option>
          </select>
        </div>

        <div class="row">
          <input id="colorPicker" type="color" value="#3b82f6" class="mini" />
          <input id="pointSize" type="range" min="0" max="12" value="4" class="small" />
        </div>

        <div class="row">
          <button id="renderBtn" class="btn">Render</button>
          <button id="downloadPNG" class="btn ghost">Download PNG</button>
          <button id="downloadCSV" class="btn ghost">Download CSV</button>
        </div>

        <div class="row" style="align-items:center">
          <label class="muted" style="display:flex;gap:8px;align-items:center"><input id="trendChk" type="checkbox" /> Overlay trendline (linear)</label>
          <label class="muted" style="display:flex;gap:8px;align-items:center"><input id="gridChk" type="checkbox" checked /> Show grid</label>
        </div>

        <div class="row">
          <input id="fileCsv" type="file" accept=".csv,text/csv" class="small" />
          <button id="loadCSV" class="btn ghost">Load CSV</button>
          <div style="flex:1"></div>
        </div>

        <div class="zoomWrap">
          <div class="zoomLabel">Premium Zoom</div>
          <input id="zoomSlider" class="zoomSlider" type="range" min="0.25" max="4" step="0.01" value="1" />
          <div style="width:6px"></div>
          <div style="min-width:70px;text-align:right;color:#cfe8ff;font-family:var(--mono)">x <span id="zoomVal">1.00</span></div>
        </div>

        <div class="muted">Double-click the chart to toggle <strong>move mode</strong>, then drag to pan. Use the premium slider to zoom smoothly.</div>
      </div>
    </div>

    <!-- Right area: chart moved to top -->
    <div class="right">
      <!-- Chart card (opaque) -->
      <div class="chartCard">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
          <div style="color:#cfe8ff;font-family:var(--mono)">Chart</div>
          <div class="moveIndicator">Mode: <strong id="modeLabel">wheel/axis</strong></div>
        </div>
        <canvas id="chartCanvas" tabindex="0"></canvas>
        <div style="display:flex;justify-content:space-between;margin-top:8px;">
          <div class="muted" style="font-size:13px">Hover axis to zoom that axis · Wheel zoom is slow by default</div>
          <div style="display:flex;gap:8px"><button id="resetBtn" class="btn ghost">Reset view</button></div>
        </div>
      </div>

      <!-- small header area (below the chart) -->
      <div class="studioTop" id="headerStage"></div>

      <div style="display:flex;gap:8px;align-items:center">
        <div class="chip">Project: <strong id="projLabel">Demo Project</strong></div>
        <div class="chip" id="dataInfo">Points: 8</div>
        <div style="flex:1"></div>
        <div class="muted">Interactive chart — pan with drag (move mode) or zoom with slider/wheel</div>
      </div>
    </div>
  </div>

  <!-- Chart libs -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.min.js"></script>

  <!-- Waves background implementation (vanilla JS) -->
  <script>
    /* --- Waves (vanilla) adapted from your code --- */
    class Grad { constructor(x,y,z){ this.x=x; this.y=y; this.z=z; } dot2(x,y){return this.x*x+this.y*y;} }
    class Noise {
      constructor(seed=0){
        this.grad3=[ new Grad(1,1,0), new Grad(-1,1,0), new Grad(1,-1,0), new Grad(-1,-1,0),
         new Grad(1,0,1), new Grad(-1,0,1), new Grad(1,0,-1), new Grad(-1,0,-1),
         new Grad(0,1,1), new Grad(0,-1,1), new Grad(0,1,-1), new Grad(0,-1,-1) ];
        this.p=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 ];
        this.perm = new Array(512); this.gradP = new Array(512); this.seed(seed);
      }
      seed(seed){
        if(seed>0 && seed<1) seed*=65536; seed=Math.floor(seed); if(seed<256) seed |= seed<<8;
        for(let i=0;i<256;i++){ let v = i & 1 ? this.p[i] ^ (seed & 255) : this.p[i] ^ ((seed >> 8) & 255); this.perm[i]=this.perm[i+256]=v; this.gradP[i]=this.gradP[i+256]=this.grad3[v%12]; }
      }
      fade(t){ return t*t*t*(t*(t*6-15)+10); }
      lerp(a,b,t){ return (1-t)*a + t*b; }
      perlin2(x,y){
        let X=Math.floor(x), Y=Math.floor(y); x-=X; y-=Y; X &=255; Y &=255;
        const n00=this.gradP[X+this.perm[Y]].dot2(x,y);
        const n01=this.gradP[X+this.perm[Y+1]].dot2(x,y-1);
        const n10=this.gradP[X+1+this.perm[Y]].dot2(x-1,y);
        const n11=this.gradP[X+1+this.perm[Y+1]].dot2(x-1,y-1);
        const u=this.fade(x);
        return this.lerp(this.lerp(n00,n10,u), this.lerp(n01,n11,u), this.fade(y));
      }
    }

    (function mountWaves(){
      const container = document.getElementById('bgContainer');
      const canvas = document.createElement('canvas');
      canvas.className = 'waves-canvas';
      container.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      const noise = new Noise(Math.random());
      let bounding = { width:0, height:0, left:0, top:0 };
      let lines = [];
      const mouse = { x:-10,y:0,lx:0,ly:0,sx:0,sy:0,v:0,vs:0,a:0,set:false };

      const config = { lineColor:'rgba(255,255,255,0.08)', waveSpeedX:0.02, waveSpeedY:0.01, waveAmpX:36, waveAmpY:18, friction:0.92, tension:0.006, maxCursorMove:120, xGap:12, yGap:36 };

      function setSize(){
        const rect = container.getBoundingClientRect();
        bounding.width = rect.width; bounding.height = rect.height; bounding.left = rect.left; bounding.top = rect.top;
        canvas.width = Math.max(1, Math.floor(bounding.width * devicePixelRatio));
        canvas.height = Math.max(1, Math.floor(bounding.height * devicePixelRatio));
        ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      }

      function setLines(){
        const { width, height } = bounding;
        lines = [];
        const oWidth = width + 200, oHeight = height + 30;
        const totalLines = Math.ceil(oWidth / config.xGap);
        const totalPoints = Math.ceil(oHeight / config.yGap);
        const xStart = (width - config.xGap * totalLines) / 2;
        const yStart = (height - config.yGap * totalPoints) / 2;
        for(let i=0;i<=totalLines;i++){
          const pts=[];
          for(let j=0;j<=totalPoints;j++){
            pts.push({ x: xStart + config.xGap*i, y: yStart + config.yGap*j, wave:{x:0,y:0}, cursor:{x:0,y:0,vx:0,vy:0} });
          }
          lines.push(pts);
        }
      }

      function movePoints(time){
        lines.forEach(pts => {
          pts.forEach(p => {
            const move = noise.perlin2((p.x + time * config.waveSpeedX)*0.002, (p.y + time * config.waveSpeedY)*0.0015)*12;
            p.wave.x = Math.cos(move) * config.waveAmpX;
            p.wave.y = Math.sin(move) * config.waveAmpY;

            const dx = p.x - mouse.sx, dy = p.y - mouse.sy; const dist = Math.hypot(dx,dy), l = Math.max(175, mouse.vs);
            if(dist < l){
              const s = 1 - dist / l; const f = Math.cos(dist * 0.001) * s;
              p.cursor.vx += Math.cos(mouse.a) * f * l * mouse.vs * 0.00065;
              p.cursor.vy += Math.sin(mouse.a) * f * l * mouse.vs * 0.00065;
            }

            p.cursor.vx += (0 - p.cursor.x) * config.tension;
            p.cursor.vy += (0 - p.cursor.y) * config.tension;
            p.cursor.vx *= config.friction; p.cursor.vy *= config.friction;
            p.cursor.x += p.cursor.vx * 2; p.cursor.y += p.cursor.vy * 2;
            p.cursor.x = Math.min(config.maxCursorMove, Math.max(-config.maxCursorMove, p.cursor.x));
            p.cursor.y = Math.min(config.maxCursorMove, Math.max(-config.maxCursorMove, p.cursor.y));
          });
        });
      }

      function moved(point, withCursor=true){ const x = point.x + point.wave.x + (withCursor?point.cursor.x:0); const y = point.y + point.wave.y + (withCursor?point.cursor.y:0); return { x: Math.round(x*10)/10, y: Math.round(y*10)/10 }; }

      function drawLines(){
        const { width, height } = bounding;
        ctx.clearRect(0,0,width,height);
        // slight tint
        const grad = ctx.createLinearGradient(0,0,0,height);
        grad.addColorStop(0,'rgba(6,8,12,0.04)'); grad.addColorStop(1,'rgba(6,8,12,0.02)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,width,height);

        ctx.strokeStyle = config.lineColor; ctx.lineWidth = 1.2; ctx.beginPath();
        lines.forEach(points => {
          let p1 = moved(points[0], false);
          ctx.moveTo(p1.x, p1.y);
          points.forEach((p, idx) => {
            const isLast = idx === points.length - 1;
            p1 = moved(p, !isLast);
            const p2 = moved(points[idx+1]||points[points.length-1], !isLast);
            ctx.lineTo(p1.x, p1.y);
            if(isLast) ctx.moveTo(p2.x,p2.y);
          });
        });
        ctx.stroke();
      }

      const tickState = { frame:null };
      function tick(time){
        mouse.sx += (mouse.x - mouse.sx) * 0.1; mouse.sy += (mouse.y - mouse.sy) * 0.1;
        const dx = mouse.x - mouse.lx, dy = mouse.y - mouse.ly; const d = Math.hypot(dx,dy);
        mouse.v = d; mouse.vs += (d - mouse.vs) * 0.1; mouse.vs = Math.min(100, mouse.vs);
        mouse.lx = mouse.x; mouse.ly = mouse.y; mouse.a = Math.atan2(dy, dx);
        movePoints(time); drawLines();
        tickState.frame = requestAnimationFrame(tick);
      }

      function onResize(){ const rect = container.getBoundingClientRect(); bounding.width = rect.width; bounding.height = rect.height; bounding.left = rect.left; bounding.top = rect.top; setSize(); setLines(); }
      function setSize(){ const rect = container.getBoundingClientRect(); bounding.width = rect.width; bounding.height = rect.height; bounding.left = rect.left; bounding.top = rect.top; canvas.width = Math.max(1, Math.floor(bounding.width * devicePixelRatio)); canvas.height = Math.max(1, Math.floor(bounding.height * devicePixelRatio)); ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); }

      function updateMouse(clientX, clientY){ mouse.x = clientX - bounding.left; mouse.y = clientY - bounding.top; if(!mouse.set){ mouse.sx = mouse.x; mouse.sy = mouse.y; mouse.lx = mouse.x; mouse.ly = mouse.y; mouse.set = true; } }

      // init
      setSize(); setLines(); tickState.frame = requestAnimationFrame(tick);
      window.addEventListener('resize', onResize);
      window.addEventListener('mousemove', (e)=> updateMouse(e.clientX, e.clientY));
      window.addEventListener('touchmove', (e)=> { if(e.touches && e.touches[0]) updateMouse(e.touches[0].clientX, e.touches[0].clientY); }, { passive: true });
      window.addEventListener('unload', ()=> { window.removeEventListener('resize', onResize); cancelAnimationFrame(tickState.frame); });
    })();
  </script>

  <!-- Chart + UI logic with move-mode panning and premium zoom slider -->
  <script>
    const projectNameIn = document.getElementById('projectName');
    const xta = document.getElementById('xvals');
    const yta = document.getElementById('yvals');
    const renderBtn = document.getElementById('renderBtn');
    const dlPNG = document.getElementById('downloadPNG');
    const dlCSV = document.getElementById('downloadCSV');
    const chartCanvas = document.getElementById('chartCanvas');
    const chartTypeSel = document.getElementById('chartType');
    const interpSel = document.getElementById('interpolation');
    const colorPicker = document.getElementById('colorPicker');
    const pointSizeRange = document.getElementById('pointSize');
    const trendChk = document.getElementById('trendChk');
    const gridChk = document.getElementById('gridChk');
    const fileCsv = document.getElementById('fileCsv');
    const loadCSV = document.getElementById('loadCSV');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomVal = document.getElementById('zoomVal');
    const modeLabel = document.getElementById('modeLabel');
    const projLabel = document.getElementById('projLabel');
    const dataInfo = document.getElementById('dataInfo');
    const resetBtn = document.getElementById('resetBtn');

    projLabel.textContent = projectNameIn.value || 'Demo Project';
    projectNameIn.addEventListener('input', ()=> projLabel.textContent = projectNameIn.value || 'Demo Project');

    function parseNumbers(text){ if(!text) return []; return text.trim().split(/[\s,;]+/).map(s=>parseFloat(s)).filter(n=>!isNaN(n)); }
    function linearRegression(xs, ys){
      const n = xs.length; let sx=0, sy=0, sxy=0, sxx=0;
      for(let i=0;i<n;i++){ sx+=xs[i]; sy+=ys[i]; sxy+=xs[i]*ys[i]; sxx+=xs[i]*xs[i]; }
      const denom = n*sxx - sx*sx;
      const m = denom === 0 ? 0 : (n*sxy - sx*sy)/denom;
      const b = (sy - m*sx)/n;
      const yhat = xs.map(x => m*x + b);
      return {m,b,yhat};
    }

    const commonOptions = {
      plugins: {
        legend: { labels: { color: '#dbeafe' } },
        tooltip: {
          backgroundColor: 'rgba(10,12,16,0.95)',
          titleColor: '#fff',
          bodyColor: '#e6eef8',
          borderColor: 'rgba(255,255,255,0.05)',
          borderWidth: 1
        },
        zoom: {
          pan: { enabled: true, mode: 'xy' },
          zoom: { wheel: { enabled: true, speed: 0.06 }, pinch: { enabled: true }, mode: 'xy' }
        }
      },
      scales: {
        x: { type: 'linear', title: { display: true, text: 'X', color: '#dbeafe' }, ticks: { color: '#cfe8ff' }, grid: { color: 'rgba(255,255,255,0.04)' } },
        y: { title: { display: true, text: 'Y', color: '#dbeafe' }, ticks: { color: '#cfe8ff' }, grid: { color: 'rgba(255,255,255,0.04)' } }
      },
      maintainAspectRatio: false, responsive: true
    };

    let chart = null;
    let originalRanges = null; // { x: {min,max}, y: {min,max} }
    let moveMode = false;
    let dragState = null;

    function createChart(){
      const xs = parseNumbers(xta.value);
      const ys = parseNumbers(yta.value);
      if(xs.length === 0 || ys.length === 0){ alert('X and Y required.'); return; }
      if(xs.length !== ys.length){ alert('X and Y must have same length.'); return; }

      const type = chartTypeSel.value;
      const tension = parseFloat(interpSel.value);
      const color = colorPicker.value;
      const pointRadius = parseInt(pointSizeRange.value,10);

      projLabel.textContent = projectNameIn.value || 'Demo Project';
      dataInfo.textContent = `Points: ${xs.length}`;

      const points = xs.map((x,i)=>({x: xs[i], y: ys[i]})).sort((a,b)=>a.x - b.x);

      const datasets = [{
        label: projLabel.textContent + ' — series',
        data: points,
        borderColor: color,
        backgroundColor: hexToRgba(color, 0.18),
        pointBackgroundColor: color,
        pointBorderColor: '#000000',
        pointRadius: pointRadius,
        showLine: type !== 'scatter' && type !== 'bar',
        tension: tension,
        fill: type === 'area' ? 'start' : false,
        parsing: false
      }];

      if(trendChk.checked){
        const xr = points.map(p=>p.x);
        const yr = points.map(p=>p.y);
        const lr = linearRegression(xr,yr);
        const trendPoints = xr.map((x,i)=>({x: xr[i], y: lr.yhat[i]}));
        datasets.push({
          label: 'Trendline (linear)',
          data: trendPoints,
          borderColor: shadeColor(color, -40),
          borderDash: [6,6],
          pointRadius: 0,
          tension: 0,
          fill: false,
          parsing: false
        });
      }

      const ctx = chartCanvas.getContext('2d');
      if(chart) chart.destroy();

      const wheelSpeed = parseFloat(zoomSlider.value) * 0.06; // wheel speed scales with slider
      const zoomOptions = {
        pan: { enabled: true, mode: 'xy' },
        zoom: { wheel: { enabled: true, speed: wheelSpeed }, pinch: { enabled: true }, mode: 'xy' }
      };

      chart = new Chart(ctx, {
        type: type === 'bar' ? 'bar' : (type === 'scatter' ? 'scatter' : 'line'),
        data: { datasets },
        options: Object.assign({}, commonOptions, { plugins: { ...commonOptions.plugins, zoom: zoomOptions }, scales: { x: commonOptions.scales.x, y: commonOptions.scales.y } })
      });

      // remember original full ranges
      const xScale = chart.scales.x;
      const yScale = chart.scales.y;
      originalRanges = {
        x: { min: xScale.min ?? xScale._getUserBounds?.().min ?? Math.min(...xs), max: xScale.max ?? Math.max(...xs) },
        y: { min: yScale.min ?? Math.min(...ys), max: yScale.max ?? Math.max(...ys) }
      };

      // set initial zoom slider to 1 and show
      zoomVal.textContent = Number(zoomSlider.value).toFixed(2);
      modeLabel.textContent = 'wheel/axis';
      chartCanvas.style.background = 'linear-gradient(180deg, rgba(0,0,0,0.78), rgba(0,0,0,0.62))';
    }

    function hexToRgba(hex, alpha){ const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16); return `rgba(${r},${g},${b},${alpha})`; }
    function shadeColor(hex, percent){ const f=parseInt(hex.slice(1),16), t=percent<0?0:255, p=percent<0?percent*-1:percent; const R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF; const newR=Math.round((t-R)*p/100)+R; const newG=Math.round((t-G)*p/100)+G; const newB=Math.round((t-B)*p/100)+B; return '#'+(0x1000000+(newR<<16)+(newG<<8)+newB).toString(16).slice(1); }

    // initial create
    createChart();

    // Zoom slider: set zoom factor relative to originalRanges center-preserving
    zoomSlider.addEventListener('input', ()=>{
      const f = parseFloat(zoomSlider.value);
      zoomVal.textContent = f.toFixed(2);
      if(!chart || !originalRanges) return;
      const xScale = chart.scales.x, yScale = chart.scales.y;
      // compute centers
      const cx = (originalRanges.x.min + originalRanges.x.max) / 2;
      const cy = (originalRanges.y.min + originalRanges.y.max) / 2;
      const newHalfX = (originalRanges.x.max - originalRanges.x.min) / 2 / f;
      const newHalfY = (originalRanges.y.max - originalRanges.y.min) / 2 / f;
      xScale.options.min = cx - newHalfX;
      xScale.options.max = cx + newHalfX;
      yScale.options.min = cy - newHalfY;
      yScale.options.max = cy + newHalfY;
      chart.update('none');
      // also update wheel speed slightly
      chart.options.plugins.zoom.zoom.wheel.speed = 0.06 * f;
    });

    // Axis hover detection (sets plugin mode)
    function updateAxisModeFromPointer(evt){
      if(!chart) return;
      const rect = chartCanvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      const area = chart.chartArea;
      if(!area) return;
      const edgeThreshold = Math.max(18, Math.min(60, Math.round(rect.height * 0.06)));
      const nearX = y >= (area.bottom - edgeThreshold) && y <= (area.bottom + edgeThreshold);
      const nearY = x <= (area.left + edgeThreshold) && x >= (area.left - edgeThreshold);
      let newMode = 'xy';
      if(nearX && !nearY) newMode = 'x';
      else if(nearY && !nearX) newMode = 'y';
      // only update when not in moveMode
      if(!moveMode){
        const curr = chart.options.plugins.zoom.zoom.mode || 'xy';
        if(curr !== newMode){
          chart.options.plugins.zoom.zoom.mode = newMode;
          chart.update('none');
        }
        modeLabel.textContent = newMode === 'xy' ? 'wheel/axis' : 'wheel → ' + newMode.toUpperCase();
      }
    }
    chartCanvas.addEventListener('mousemove', updateAxisModeFromPointer);
    chartCanvas.addEventListener('pointermove', updateAxisModeFromPointer);

    // Move mode: double click to toggle; in move mode click+drag pans the chart by changing axis min/max
    chartCanvas.addEventListener('dblclick', (e)=>{
      moveMode = !moveMode;
      modeLabel.textContent = moveMode ? 'move (drag to pan)' : 'wheel/axis';
      chartCanvas.classList.toggle('dragging', false);
      // when entering move mode, disable plugin pan/zoom temporarily (we handle pan ourselves)
      chart.options.plugins.zoom.pan.enabled = !moveMode ? true : false;
      chart.options.plugins.zoom.zoom.wheel.enabled = !moveMode ? true : false;
      chart.update('none');
    });

    // handle drag panning
    chartCanvas.addEventListener('mousedown', (e)=>{
      if(!moveMode) return;
      e.preventDefault();
      chartCanvas.classList.add('dragging');
      const rect = chartCanvas.getBoundingClientRect();
      dragState = {
        startX: e.clientX,
        startY: e.clientY,
        rectLeft: rect.left,
        rectTop: rect.top,
        xMinStart: chart.scales.x.min,
        xMaxStart: chart.scales.x.max,
        yMinStart: chart.scales.y.min,
        yMaxStart: chart.scales.y.max
      };
      window.addEventListener('mousemove', onDrag);
      window.addEventListener('mouseup', onDragEnd, { once: true });
    });

    function onDrag(e){
      if(!dragState) return;
      const dx = e.clientX - dragState.startX;
      const dy = e.clientY - dragState.startY;
      const chartArea = chart.chartArea;
      const width = chartArea.right - chartArea.left;
      const height = chartArea.bottom - chartArea.top;
      if(width <= 0 || height <= 0) return;
      const xRange = dragState.xMaxStart - dragState.xMinStart;
      const yRange = dragState.yMaxStart - dragState.yMinStart;
      // convert pixel delta to data delta (note sign: moving right should shift view left)
      const deltaXData = (dx / width) * xRange;
      const deltaYData = (dy / height) * yRange;
      chart.scales.x.options.min = dragState.xMinStart - deltaXData;
      chart.scales.x.options.max = dragState.xMaxStart - deltaXData;
      chart.scales.y.options.min = dragState.yMinStart + deltaYData;
      chart.scales.y.options.max = dragState.yMaxStart + deltaYData;
      chart.update('none');
    }

    function onDragEnd(){
      chartCanvas.classList.remove('dragging');
      dragState = null;
      window.removeEventListener('mousemove', onDrag);
    }

    // Reset view button
    resetBtn.addEventListener('click', ()=>{
      if(!chart || !originalRanges) return;
      chart.scales.x.options.min = originalRanges.x.min;
      chart.scales.x.options.max = originalRanges.x.max;
      chart.scales.y.options.min = originalRanges.y.min;
      chart.scales.y.options.max = originalRanges.y.max;
      chart.update();
      zoomSlider.value = 1; zoomVal.textContent = '1.00';
    });

    // CSV load
    loadCSV.addEventListener('click', ()=>{
      if(!fileCsv.files || fileCsv.files.length===0){ alert('Choose a CSV file'); return; }
      const file = fileCsv.files[0];
      const reader = new FileReader();
      reader.onload = (e)=>{
        const text = e.target.result;
        const lines = text.trim().split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
        const pairs = lines.map(l => l.split(/[\t,;]+/).map(s=>s.trim()).filter(Boolean));
        const nums = pairs.filter(p => p.length>=2 && !isNaN(parseFloat(p[0])) && !isNaN(parseFloat(p[1])));
        if(nums.length===0){ alert('No numeric rows found'); return; }
        const xs = nums.map(r=>parseFloat(r[0]));
        const ys = nums.map(r=>parseFloat(r[1]));
        xta.value = xs.join(',');
        yta.value = ys.join(',');
        createChart();
      };
      reader.readAsText(file);
    });

    // UI buttons and interactions
    renderBtn.addEventListener('click', createChart);
    dlPNG.addEventListener('click', ()=>{ if(!chart){ alert('Render first'); return; } const a=document.createElement('a'); a.href=chartCanvas.toDataURL('image/png'); a.download=(projectNameIn.value||'chart')+'.png'; a.click(); });
    dlCSV.addEventListener('click', ()=>{ const xs=parseNumbers(xta.value), ys=parseNumbers(yta.value); if(xs.length!==ys.length){ alert('X/Y mismatch'); return; } const rows=['x,y', ...xs.map((x,i)=>`${x},${ys[i]}`)].join('\n'); const blob=new Blob([rows],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=(projectNameIn.value||'chart')+'.csv'; a.click(); URL.revokeObjectURL(url); });

    [gridChk, chartTypeSel, interpSel, colorPicker, pointSizeRange, trendChk].forEach(el => el?.addEventListener('change', ()=> { if(chart) createChart(); }));
    document.addEventListener('keydown', (e)=>{ if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){ createChart(); } });

    // tiny helpers
    function parseNumbers(text){ if(!text) return []; return text.trim().split(/[\s,;]+/).map(s=>parseFloat(s)).filter(n=>!isNaN(n)); }
    function hexToRgba(hex, alpha){ const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16); return `rgba(${r},${g},${b},${alpha})`; }
    function shadeColor(hex, percent){ const f=parseInt(hex.slice(1),16), t=percent<0?0:255, p=percent<0?percent*-1:percent; const R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF; const newR=Math.round((t-R)*p/100)+R; const newG=Math.round((t-G)*p/100)+G; const newB=Math.round((t-B)*p/100)+B; return '#'+(0x1000000+(newR<<16)+(newG<<8)+newB).toString(16).slice(1); }
  </script>
</body>
</html>

